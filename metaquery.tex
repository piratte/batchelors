\chapter{The Metaquery}

When working with metadata in the DFC's metadata catalog, one of the most important operations is 
to find files by giving a specific set of conditions on their metadata. Each condition concerning
one metafield is called term and is in the form of \texttt{<metafield> <operator> <value>}, where
metafield is name of the metadata field, operator is one of the classical comparison operators:
\texttt{=},\texttt{!=},\texttt{<},\texttt{<=},\texttt{>},\texttt{>=} and value is the value
specifying the condition. In the current production implementation the terms are coupled 
together by writing them in a space separated list which translates into a conjunction with
each space having the same meaning as the logical operator \texttt{AND}.

As the DFC grows bigger and more elaborate, the need for new classes emerges. Before the 
start of this project, the information about the metaquery was stored in a python dictionary
data structure and every operation upon it was done in the code of the concrete procedure. 
Because the handling was done similarly in several places a decision was made to create a 
Metaquery class to encapsulate all the handling methods. 

There was also a need for extending the metaquery language by adding the logical operators 
\texttt{OR} and \texttt{NOT} and allowing brackets. Another task was set when the demand for
the user input to be optimized and normalized was raised. This meant that if two users 
inserted two equivalent metaqueries but wrote them down 
differently\footnote{e.g. \texttt{A=2 AND (B>3 OR C!=4)} vs. \texttt{A=2 AND B>3 OR A=2 AND C!=4}}, 
internally they would be stored the same way. This is opening an option for the metaquery 
to be hashed so that all the equivalent metaqueries would have the same hash and thus it 
could be used as a database index etc. The task of studying all the possible utilizations of the 
metaquery hash is not the aim of this project but should be engaged in the future. 

\section{Metaquery theory}

When evaluating the trueness of a formula on a given substitution of its free variables, the 
form that comes in mind is the disjunctive normal form (DNF). A logical formula is in DNF if
it is a disjunction of at least one conjunction of at least one literal. In our case literals 
are the terms specifying conditions on metadata and the variable substitution is the trueness
of the term when a specific value of metadata is subsituted for the metafield name. The whole
formula is then true when at least one of the disjuncts evaluates as true, which makes evaluating
the trueness of the formula on a given set of metadata values rather easy.

To be able to use this form, an efficient practical implementation had to be discussed, having in 
mind that backwards compatibility with the old metaquery representation is a key issue. The decision 
was made to represent the formula in DNF using a list of dictionaries, where each dictionary 
represents one conjunct of the outer disjunction. This is similar to the status before this project
when only one dictionary was used to represent a conjunction of terms. 

\section{Metaquery in practice}

The Metaqury class contains 
\begin{itemize}
\item the information about the metaquery itself written in a form of list,
\item information about the types of all the metafields,
\item handling methods and functions.
\end{itemize}
Serialization of the class is done by exporting the list containing information about the formula. 
When a handling method has to be used somewhere in the code, a new instance of the class is created 
using this list. This helps to limit the network traffic to a minimum. 

The class has a constructor taking 2 parameters: \texttt{queryList} the list representation of the 
metaquery and \texttt{typeDict} the dictionary of metafield types. When a new metaquery is to be 
created from a user input, an instance of the Metaquery class is created without any information
about the query itself, but ideally using a valid \texttt{typeDict}. Then the query string is parsed, tokenized and fed into the \texttt{setMetaQuery} method.

\begin{listing}
\begin{minted}{python}
# typeDict is set earlier in the function
mq = MetaQuery( typeDict = typeDict )
mq.setMetaQuery( mq.parseQueryString(userInputString) )
\end{minted}
\caption{Creating an instance of the Metaquery class using user input}
\end{listing}

The tokenizing has to be done character by character to allow the user to input a query without 
caring about whitespace distribution. If the user wants to use the old input method\footnote{
Query string is in form \texttt{<metafield> <operator> <value> [<metafield> <operator> <value>]*}}
it is possible and the output will be one conjunction as expected (AND operators are added in the
correct places). However when the user uses at least one logical operator, no other additions are made
and the rest of the input has to be correctly formed. The method \texttt{setMetaQuery} takes care of 
the normalizing (converting to DNF) and optimizing of the formula. Every logical formula 
can be transferred to DNF\footnote{}.% <- proof that every formula can be transfered to DNF
